{% extends "layout.html" %}

{% block styles %}
body {
  overflow: hidden;
}

canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
}

.fullscreen-bg {
  position: fixed;
  top: 50%;
  left: 50%;
  width: calc(100vw + 32px);
  height: calc(100vh + 32px);
  background-image: url("/ocean-10.jpg");
  background-size: cover;
  /* Allow small animated offsets via CSS variables */
  background-position: calc(50% + var(--bg-offset-x, 0px)) calc(15% + var(--bg-offset-y, 0px));
  background-repeat: no-repeat;
  transform: translate(-50%, -50%);
  z-index: 1;
  transition: background-image 0.5s ease-in-out;
  will-change: background-position;
}

.dotted-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  z-index: 2;
  background-image:
    repeating-linear-gradient(
      to bottom,
      rgba(127, 127, 127, 0.17),
      rgba(127, 127, 127, 0.17) 3px,
      rgba(0, 0, 0, 0) 3px,
      rgba(0, 0, 0, 0) 6px
    ),
    radial-gradient(rgba(255, 255, 255, 0.28) 1px, rgba(0, 0, 0, 0) 1px);
  background-size: 100% 3px, 3px 3px;
  background-position: 0 0, 0 0;
  mix-blend-mode: overlay;
}

.main-image {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 333px;
  max-width: 65vw;
  object-fit: contain;
  object-position: center;
  transform: translate(-50%, -50%);
  z-index: 1;
  opacity: 1;
}

.main-image {
  font-size: 0;
  color: transparent;
}

.main-image::before {
  content: none;
}

.main-image::after {
  content: none;
}

.nav-links {
  position: fixed;
  top: calc(50% + 200px);
  left: 50%;
  transform: translateX(-50%);
  z-index: 3;
  display: flex;
  gap: 30px;
  opacity: 0;
}

.nav-links a {
  font-family: 'EB Garamond', 'Times New Roman', serif;
  font-weight: 500;
  font-size: 24px;
  color: rgba(255, 255, 255, 0.8);
  text-decoration: none;
  transition: color 0.3s ease;
}

.nav-links a:hover {
  color: rgba(255, 255, 255, 1);
}

/* Corner text styles */
.corner-text {
  position: fixed;
  font-family: 'EB Garamond', 'Times New Roman', serif;
  font-weight: 500;
  font-size: 18px;
  cursor: pointer;
  z-index: 3;
  user-select: none;
  padding: 30px;
  overflow: hidden;
}

.corner-text:hover {
  color: rgba(255, 255, 255, 1);
}

.top-left {
  top: 0;
  left: 0;
}

.top-right {
  top: 0;
  right: 0;
}

.bottom-left {
  bottom: 0;
  left: 0;
}

.bottom-right {
  bottom: 0;
  right: 0;
}

.text-container {
  position: relative;
  display: inline-grid;
  vertical-align: bottom;
  filter: url(#threshold) blur(0.6px);
  transform-origin: top left;
  transform: scale(0.5);
}

.top-right .text-container { transform-origin: top right; }

/* Ensure top corners sit flush with the top edge on large screens */
.top-left .text-container,
.top-right .text-container {
  vertical-align: top;
}

/* For bottom corners, anchor the scaled box to the bottom
   so the visible text sits on the container's bottom edge. */
.bottom-left .text-container { transform-origin: bottom left; }
.bottom-right .text-container { transform-origin: bottom right; }

/* Overlay both text variants while letting container size naturally */
.text-container > .text-version { grid-area: 1 / 1; }

/* Align content within the container based on corner */
.top-left .text-container
.top-right .text-container { align-items: start; }
.bottom-left .text-container,
.bottom-right .text-container { align-items: end; }
.top-left .text-container,
.bottom-left .text-container { justify-items: start; }
.top-right .text-container,
.bottom-right .text-container { justify-items: end; }

.text-version {
  color: rgba(255, 255, 255, 1);
  white-space: nowrap;
  font-size: 200%;
  transition: filter 1.2s ease-in-out, opacity 1.2s ease-in-out;
  display: block;
}

/* Right alignment handled by grid on container */

.corner-text:hover .text-version {
  color: rgba(255, 255, 255, 1);
}

@media (prefers-reduced-motion: reduce) {
  .fullscreen-bg { will-change: auto; }
  .dotted-overlay { animation: none; opacity: 0.06; }
}

@media (min-width: 900px) {
  .corner-text { font-size: 24px; }
}

/* Small screens < 800px: stack tightly at bottom-right and enlarge text by 10% */
@media (max-width: 800px) {
  .corner-texts-wrapper {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    z-index: 3;
    padding: 8px !important;
  }

  /* Make each item tight with no inner padding/margins and 10% bigger */
  .corner-texts-wrapper .corner-text {
    font-size: 110% !important;
    display: block;
    bottom: initial;
    top: initial;
    left: initial;
    right: initial;
    position: initial;
    padding: 0;
  }

  /* Remove scale-based layout gap; use natural size instead */
  .corner-texts-wrapper .text-container {
    transform: none !important;
    display: inline-grid !important;
    line-height: 1.3 !important; /* avoid extra line box */
  }

  /* Keep the texts right-aligned and 1x size when unscaled */
  .corner-texts-wrapper .text-version {
    left: 0;
    font-size: 110%;
  }

  .top-left .text-container
  .top-right .text-container { align-items: start; }
  .bottom-left .text-container,
  .bottom-right .text-container { align-items: start; }
  .top-left .text-container,
  .bottom-left .text-container { justify-items: start; }
  .top-right .text-container,
  .bottom-right .text-container { justify-items: start; }

  /* Tweak nav for small screens */
  .nav-links {
    top: calc(50% + 150px);
    gap: 15px;
    text-align: center;
  }
  .nav-links a { font-size: 22px; }
}

/* move logo up to make space for small corner text */
@media (max-width: 800px) and (max-height: 700px) {
  .main-image {
    top: calc(50% - 15vh);
  }
  .nav-links {
    top: 5vh;
  }
}

{% endblock %}

{% block body %}
<div class="fullscreen-bg"></div>
<div class="dotted-overlay" aria-hidden="true"></div>
<img src="/logo.svg" class="main-image" alt="" aria-hidden="true">
<div class="nav-links">
  <a href="/memo/">memo</a>
  <a href="/careers/">careers</a>
</div>

<!-- SVG filter for text morphing -->
<svg id="filters" style="position: absolute; width: 0; height: 0;">
  <defs>
    <filter id="threshold">
      <feColorMatrix in="SourceGraphic"
        type="matrix"
        values="1 0 0 0 0
                0 1 0 0 0
                0 0 1 0 0
                0 0 0 255 -120" />
    </filter>
  </defs>
</svg>

<!-- Corner texts -->
<div class="corner-texts-wrapper">
  <div class="corner-text top-left" id="text-tl"
       data-elven="Antorya i fairë Fírimion"
       data-english="Strengthen the agency of humanity">
    <div class="text-container">
      <span class="text-version elven visible">Antorya i fairë Fírimion</span>
      <span class="text-version english hidden">Strengthen the agency of humanity</span>
    </div>
  </div>

  <div class="corner-text top-right" id="text-tr"
       data-elven="Finya osanwë ar látanë axani"
       data-english="Craft software and open protocols">
    <div class="text-container">
      <span class="text-version elven visible">Finya osanwë ar látanë axani</span>
      <span class="text-version english hidden">Craft software and open protocols</span>
    </div>
  </div>

  <div class="corner-text bottom-left" id="text-bl"
       data-elven="Yantā yáwë ar laista"
       data-english="Bridge division and ignorance">
    <div class="text-container">
      <span class="text-version elven visible">Yantā yáwë ar laista</span>
      <span class="text-version english hidden">Bridge division and ignorance</span>
    </div>
  </div>

  <div class="corner-text bottom-right" id="text-br"
       data-elven="Alta alassë ar handë oira"
       data-english="Cultivate lasting joy and understanding">
    <div class="text-container">
      <span class="text-version elven visible">Alta alassë ar handë oira</span>
      <span class="text-version english hidden">Cultivate lasting joy and understanding</span>
    </div>
  </div>
</div>

<script>
  (function () {
    const bg = document.querySelector('.fullscreen-bg');
    const img = document.querySelector('.main-image');
    const navLinks = document.querySelector('.nav-links');

    bg.style.opacity = '0';
    setTimeout(() => {
      bg.style.transition = 'opacity 2s';
      bg.style.opacity = '1.0';
    }, 250);

    img.style.opacity = '0';
    setTimeout(() => {
      img.style.transition = 'opacity 3s';
      img.style.opacity = '0.9';
    }, 600);

    // Animate logo transform
    img.style.transform = 'translate(-50%, calc(-50% - 3vh)) scale(1.1) perspective(800px) rotateX(15deg)';
    setTimeout(() => {
      img.style.transition = 'opacity 2s, transform 2s ease-out';
      img.style.transform = 'translate(-50%, -50%) scale(1) perspective(800px) rotateX(0deg)';
    }, 600);

    // Animate nav links transform
    navLinks.style.opacity = '0';
    navLinks.style.transform = 'translate(-50%, 3vh) scale(1.1)';
    setTimeout(() => {
      navLinks.style.transition = 'opacity 2s ease, transform 2s ease-out';
      navLinks.style.opacity = '1';
      navLinks.style.transform = 'translateX(-50%) scale(1)';
    }, 600);

    // Corner text language switching
    const cornerTexts = document.querySelectorAll('.corner-text');

    // Detect if device is mobile/touch-enabled
    const isMobile = window.matchMedia('(max-width: 768px)').matches ||
                     'ontouchstart' in window ||
                     navigator.maxTouchPoints > 0;

    // Track default language for each corner text (starts as elven)
    const defaultLanguages = new Map();
    const morphStates = new Map();
    const MORPH_DURATION = 0.85;
    const INITIAL_ELVEN_REVEAL_DURATION = 3.5; // seconds
    let initialRevealActive = true;

    // Utility: apply blur+opacity for a given fraction (0..1)
    function setMorph(cornerElement, fraction) {
      const elvenSpan = cornerElement.querySelector('.text-version.elven');
      const englishSpan = cornerElement.querySelector('.text-version.english');

      // Clamp to avoid division by zero in blur formula
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      let f = clamp(fraction, 0.0001, 0.9999);

      // English visibility follows f; Elven follows (1-f)
      const englishBlur = Math.min(8 / f - 8, 100);
      const elvenBlur = Math.min(8 / (1 - f) - 8, 100);

      const englishOpacity = Math.pow(f, 0.4);
      const elvenOpacity = Math.pow(1 - f, 0.4);

      englishSpan.style.filter = `blur(${englishBlur}px)`;
      englishSpan.style.opacity = `${englishOpacity}`;

      elvenSpan.style.filter = `blur(${elvenBlur}px)`;
      elvenSpan.style.opacity = `${elvenOpacity}`;
    }

    // Start a morph animation towards target language for a specific element
    function startMorph(cornerElement, targetLanguage) {
      let state = morphStates.get(cornerElement);
      if (!state) {
        state = { f: 0, raf: null };
        morphStates.set(cornerElement, state);
      }

      const targetF = targetLanguage === 'english' ? 1 : 0;
      const startF = state.f;
      const startTime = performance.now();

      if (state.raf) cancelAnimationFrame(state.raf);

      const step = (now) => {
        const t = (now - startTime) / (MORPH_DURATION * 1000);
        // Ease in/out for smoother motion
        const ease = t <= 0 ? 0 : t >= 1 ? 1 : (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);
        const f = startF + (targetF - startF) * ease;
        state.f = f;
        setMorph(cornerElement, f);
        if (t < 1) {
          state.raf = requestAnimationFrame(step);
        } else {
          state.raf = null;
          // Snap to exact target at end
          state.f = targetF;
          setMorph(cornerElement, targetF);
        }
      };

      state.raf = requestAnimationFrame(step);
    }

    // Ensure CSS transitions don't interfere with JS morphing

    cornerTexts.forEach(cornerText => {
      defaultLanguages.set(cornerText, 'elven');
      const elvenSpan = cornerText.querySelector('.text-version.elven');
      const englishSpan = cornerText.querySelector('.text-version.english');
      // Remove CSS transitions so JS-driven morphing takes precedence
      elvenSpan.style.transition = 'none';
      englishSpan.style.transition = 'none';
      // Initialize morph state, but start with both hidden for reveal
      morphStates.set(cornerText, { f: 0, raf: null });
      elvenSpan.style.opacity = '0';
      elvenSpan.style.filter = 'blur(100px)';
      englishSpan.style.opacity = '0';
      englishSpan.style.filter = 'blur(100px)';
    });

    // Stacked layout spacing handled via CSS media queries

    // Initial reveal animation for Elvish text only (from full transparency)
    function startInitialReveal(cornerElement, durationSec) {
      const elvenSpan = cornerElement.querySelector('.text-version.elven');
      const start = performance.now();
      const step = (now) => {
        const t = (now - start) / (durationSec * 1000);
        const clamped = t <= 0 ? 0 : t >= 1 ? 1 : t;
        // Ease in-out cubic
        const ease = clamped < 0.5
          ? 4 * clamped * clamped * clamped
          : 1 - Math.pow(-2 * clamped + 2, 3) / 2;
        // Use similar blur falloff as morph for visual consistency
        const f = Math.max(ease, 0.0001);
        const blur = Math.min(8 / f - 8, 100);
        const opacity = Math.pow(ease, 0.4);
        elvenSpan.style.filter = `blur(${blur}px)`;
        elvenSpan.style.opacity = `${opacity}`;
        if (clamped < 1) {
          requestAnimationFrame(step);
        } else {
          // Snap to stable morph baseline (Elvish fully visible)
          setMorph(cornerElement, 0);
        }
      };
      requestAnimationFrame(step);
    }

    // Kick off initial reveal for all corners
    cornerTexts.forEach(cornerText => startInitialReveal(cornerText, INITIAL_ELVEN_REVEAL_DURATION));
    // Allow interactions after reveal completes
    setTimeout(() => { initialRevealActive = false; }, INITIAL_ELVEN_REVEAL_DURATION * 1000);

    cornerTexts.forEach(cornerText => {
      let isHovering = false;

      if (!isMobile) {
        // Desktop: hover to temporarily show English, return to default on mouse leave
        cornerText.addEventListener('mouseenter', () => {
          if (initialRevealActive) return;
          isHovering = true;
          startMorph(cornerText, 'english');
        });

        cornerText.addEventListener('mouseleave', () => {
          if (initialRevealActive) return;
          isHovering = false;
          const defaultLang = defaultLanguages.get(cornerText);
          startMorph(cornerText, defaultLang);
        });
      }

      // Click/tap: toggle default language
      cornerText.addEventListener('click', (e) => {
        if (initialRevealActive) return;
        const currentDefault = defaultLanguages.get(cornerText);
        const newDefault = currentDefault === 'elven' ? 'english' : 'elven';
        defaultLanguages.set(cornerText, newDefault);

        // Morph to new default
        if (isMobile || !isHovering) {
          startMorph(cornerText, newDefault);
        }
      });
    });

    // Background "wiggle" motion: smooth random walk within ~5px bounds
    (function setupBackgroundWiggle() {
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (!bg || reduceMotion) return;

      const MAX = 10; // max px offset in any direction
      const CHANGE_INTERVAL_MS = 700; // pick a new target roughly every ~1s
      const SMOOTHING = 0.01; // how quickly we ease toward target per frame

      let currentX = 0, currentY = 0;
      let targetX = 0, targetY = 0;
      let lastChange = performance.now();

      function pickNewTarget() {
        // Pick within a circle of radius MAX for more natural bounds
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * MAX;
        targetX = Math.cos(angle) * radius;
        targetY = Math.sin(angle) * radius;
      }

      function animate(now) {
        if (now - lastChange > CHANGE_INTERVAL_MS) {
          pickNewTarget();
          lastChange = now;
        }
        // Ease towards the target
        currentX += (targetX - currentX) * SMOOTHING;
        currentY += (targetY - currentY) * SMOOTHING;

        // Add a tiny high-frequency jitter for a VHS feel
        const jitterX = (Math.random() - 0.5) * 0.3;
        const jitterY = (Math.random() - 0.5) * 0.3;

        bg.style.setProperty('--bg-offset-x', (currentX + jitterX).toFixed(2) + 'px');
        bg.style.setProperty('--bg-offset-y', (currentY + jitterY).toFixed(2) + 'px');

        requestAnimationFrame(animate);
      }

      pickNewTarget();
      requestAnimationFrame(animate);
    })();
  })();
</script>
{% endblock %}
